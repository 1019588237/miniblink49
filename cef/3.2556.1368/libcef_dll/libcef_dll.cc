// Copyright (c) 2015 The Chromium Embedded Framework Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the CEF translator tool. If making changes by
// hand only do so within the body of existing method and function
// implementations. See the translator.README.txt file in the tools directory
// for more information.
//

#include "include/cef_app.h"
#include "include/capi/cef_app_capi.h"
#include "include/cef_geolocation.h"
#include "include/capi/cef_geolocation_capi.h"
#include "include/cef_origin_whitelist.h"
#include "include/capi/cef_origin_whitelist_capi.h"
#include "include/cef_parser.h"
#include "include/capi/cef_parser_capi.h"
#include "include/cef_path_util.h"
#include "include/capi/cef_path_util_capi.h"
#include "include/cef_process_util.h"
#include "include/capi/cef_process_util_capi.h"
#include "include/cef_scheme.h"
#include "include/capi/cef_scheme_capi.h"
#include "include/cef_task.h"
#include "include/capi/cef_task_capi.h"
#include "include/cef_trace.h"
#include "include/capi/cef_trace_capi.h"
#include "include/cef_v8.h"
#include "include/capi/cef_v8_capi.h"
#include "include/cef_web_plugin.h"
#include "include/capi/cef_web_plugin_capi.h"
#include "include/cef_version.h"
#include "include/internal/cef_thread_internal.h"
#include "include/capi/cef_client_capi.h"

#include "libcef_dll/ctocpp/v8handler_ctocpp.h"
#include "libcef_dll/ctocpp/scheme_handler_factory_ctocpp.h"

#include "libcef/common/StringUtil.h"

#include "cef/libcef/browser/CefGlobal.h"
#include "content/browser/WebPage.h"

using namespace blink;

CefGlobal* g_cefGlobal = nullptr;

// CEF_EXPORT int cef_execute_process(const cef_main_args_t* args, cef_app_t* application, void* windows_sandbox_info) {
//     
//     return 1;
// }
// 
// CEF_EXPORT int cef_initialize(const cef_main_args_t* args, const cef_settings_t* settings, cef_app_t* application, void* windows_sandbox_info) {
//     content::WebPage::initBlink();
// 
//     if (!g_cefGlobal) {
//         g_cefGlobal = new CefGlobal();
//         g_cefGlobal->m_mainArgs = args;
//     }
// 
//     if (application) {
//         g_cefGlobal->m_resourceBundleHandler = application->get_resource_bundle_handler(application);
//         g_cefGlobal->m_browserProcessHandler = application->get_browser_process_handler(application);
//         g_cefGlobal->m_renderProcessHandler = application->get_render_process_handler(application);
//     }
// 
//     if (g_cefGlobal->m_browserProcessHandler) {
//         g_cefGlobal->m_browserProcessHandler->on_context_initialized(g_cefGlobal->m_browserProcessHandler);
//         g_cefGlobal->m_browserProcessHandler->on_before_child_process_launch(g_cefGlobal->m_browserProcessHandler, cef_command_line_get_global());
//         g_cefGlobal->m_browserProcessHandler->on_render_process_thread_created(g_cefGlobal->m_browserProcessHandler, nullptr);
//         //g_cefGlobal->m_browserProcessHandler->get_print_handler(g_cefGlobal->m_browserProcessHandler);
//     }
// 
//     if (g_cefGlobal->m_renderProcessHandler) {
//         g_cefGlobal->m_renderProcessHandler->on_render_thread_created(g_cefGlobal->m_renderProcessHandler, nullptr);
//         g_cefGlobal->m_renderProcessHandler->on_web_kit_initialized(g_cefGlobal->m_renderProcessHandler);
//     }
// 
//     return 1;
// }
// 
// CEF_EXPORT void cef_shutdown() {
//   // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
// 
//   // Execute
//   // CefShutdown();
// 
// }
// 
// 
// CEF_EXPORT void cef_do_message_loop_work() {
// 
// }
// 
// CEF_EXPORT void cef_run_message_loop() {
//     MSG msg;
//     HACCEL hAccelTable = nullptr; // LoadAccelerators(g_cefGlobal->m_mainArgs->instance, MAKEINTRESOURCE(szWindowClass));
// 
//     while (GetMessage(&msg, NULL, 0, 0)) {
//         if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) {
//             TranslateMessage(&msg);
//             DispatchMessage(&msg);
//         }
//     }
// }
// 
// CEF_EXPORT void cef_quit_message_loop() {
// 
// }
// 
// CEF_EXPORT void cef_set_osmodal_loop(int osModalLoop) {
//     
// }
// 
// CEF_EXPORT void cef_enable_highdpi_support() {
//     
// }

CEF_EXPORT int cef_get_geolocation(struct _cef_get_geolocation_callback_t* callback) {
    DebugBreak();
    return -1;
}

CEF_EXPORT int cef_add_cross_origin_whitelist_entry(
    const cef_string_t* source_origin, const cef_string_t* target_protocol,
    const cef_string_t* target_domain, int allow_target_subdomains) {
    DebugBreak();
    return -1;
}

CEF_EXPORT int cef_remove_cross_origin_whitelist_entry(
    const cef_string_t* source_origin, const cef_string_t* target_protocol,
    const cef_string_t* target_domain, int allow_target_subdomains) {
    DebugBreak();
    return -1;
}

CEF_EXPORT int cef_clear_cross_origin_whitelist() {
    DebugBreak();
    return -1;
}



CEF_EXPORT int cef_parse_url(const cef_string_t* url, cef_urlparts_t* parts) {
    blink::KURL kurl(ParsedURLString, String(url->str, url->length).utf8().data());
    if (!kurl.isValid())
        return false;

    memset(parts, 0, sizeof(cef_urlparts_t));

    cef::String16ToCefOriginalString16(kurl.string().charactersWithNullTermination().data(), &parts->spec);
    cef::String16ToCefOriginalString16(kurl.protocol().charactersWithNullTermination().data(), &parts->scheme);
    cef::String16ToCefOriginalString16(kurl.host().charactersWithNullTermination().data(), &parts->host);
    cef::String16ToCefOriginalString16(kurl.string().charactersWithNullTermination().data(), &parts->origin);
    cef::String16ToCefOriginalString16(L"/", &parts->path);

    return true;
}

CEF_EXPORT int cef_create_url(const struct _cef_urlparts_t* parts,
    cef_string_t* url) {
    return -1;
}

CEF_EXPORT cef_string_userfree_t cef_format_url_for_security_display(
    const cef_string_t* origin_url, const cef_string_t* languages) {
    DebugBreak();
    return nullptr;
}

CEF_EXPORT cef_string_userfree_t cef_get_mime_type(
    const cef_string_t* extension) {
    DebugBreak();
    return nullptr;
}

CEF_EXPORT void cef_get_extensions_for_mime_type(const cef_string_t* mime_type,
    cef_string_list_t extensions) {
    DebugBreak();
    return;
}

CEF_EXPORT cef_string_userfree_t cef_base64encode(const void* data,
    size_t data_size) {
    DebugBreak();
    return nullptr;
}

CEF_EXPORT struct _cef_binary_value_t* cef_base64decode(
    const cef_string_t* data) {
    return nullptr;
}

CEF_EXPORT cef_string_userfree_t cef_uriencode(const cef_string_t* text,
    int use_plus) {
    DebugBreak();
    return nullptr;
}

CEF_EXPORT cef_string_userfree_t cef_uridecode(const cef_string_t* text,
    int convert_to_utf8, cef_uri_unescape_rule_t unescape_rule) {
    return nullptr;
}

CEF_EXPORT int cef_parse_csscolor(const cef_string_t* string, int strict,
    cef_color_t* color) {
    return -1;
}

CEF_EXPORT struct _cef_value_t* cef_parse_json(const cef_string_t* json_string,
    cef_json_parser_options_t options) {
    DebugBreak();
    return nullptr;
}

CEF_EXPORT struct _cef_value_t* cef_parse_jsonand_return_error(
    const cef_string_t* json_string, cef_json_parser_options_t options,
    cef_json_parser_error_t* error_code_out, cef_string_t* error_msg_out) {
    DebugBreak();
    return nullptr;
}

CEF_EXPORT cef_string_userfree_t cef_write_json(struct _cef_value_t* node,
    cef_json_writer_options_t options) {
    DebugBreak();
    return nullptr;
}

CEF_EXPORT int cef_get_path(cef_path_key_t key, cef_string_t* path) {
    DebugBreak();
    return -1;
}

CEF_EXPORT int cef_launch_process(struct _cef_command_line_t* command_line) {
    DebugBreak();
    return -1;
}

CEF_EXPORT int cef_register_scheme_handler_factory(const cef_string_t* scheme_name, const cef_string_t* domain_name, cef_scheme_handler_factory_t* factory) {
    // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

    // Verify param: scheme_name; type: string_byref_const
    DCHECK(scheme_name);
    if (!scheme_name)
        return 0;
    // Unverified params: domain_name, factory

    // Execute
    bool _retval = CefRegisterSchemeHandlerFactory(
        CefString(scheme_name),
        CefString(domain_name),
        CefSchemeHandlerFactoryCToCpp::Wrap(factory));

    // Return type: bool
    return _retval;
}

CEF_EXPORT int cef_clear_scheme_handler_factories() {
    return -1;
}

CEF_EXPORT int cef_currently_on(cef_thread_id_t threadId) {
    return 1;
}

CEF_EXPORT int cef_post_task(cef_thread_id_t threadId, struct _cef_task_t* task) {
    DebugBreak();
    return -1;
}

CEF_EXPORT int cef_post_delayed_task(cef_thread_id_t threadId,
struct _cef_task_t* task, int64 delay_ms) {
    DebugBreak();
    return -1;
}

CEF_EXPORT int cef_begin_tracing(const cef_string_t* categories,
struct _cef_completion_callback_t* callback) {
    DebugBreak();
    return -1;
}

CEF_EXPORT int cef_end_tracing(const cef_string_t* tracing_file,
struct _cef_end_tracing_callback_t* callback) {
    DebugBreak();
    return -1;
}

CEF_EXPORT int64 cef_now_from_system_trace_time() {
    DebugBreak();
    return -1;
}

CEF_EXPORT int cef_register_extension(const cef_string_t* extension_name, const cef_string_t* javascript_code, struct _cef_v8handler_t* handler) {
    //CefRefPtr<CefV8Handler> cef_handler = CefV8HandlerCppToC::Get(handler);
    CefRefPtr<CefV8Handler> cef_handler = CefV8HandlerCToCpp::Wrap(handler);

    bool _retval = CefRegisterExtension(CefString(extension_name), CefString(javascript_code), cef_handler);
    return _retval  ? 1 : 0;
}

CEF_EXPORT void cef_visit_web_plugin_info(struct _cef_web_plugin_info_visitor_t* visitor) {
    DebugBreak();
}

CEF_EXPORT void cef_refresh_web_plugins() {
    DebugBreak();
}

CEF_EXPORT void cef_add_web_plugin_path(const cef_string_t* path) {
    DebugBreak();
}

CEF_EXPORT void cef_add_web_plugin_directory(const cef_string_t* dir) {
    DebugBreak();
}

CEF_EXPORT void cef_remove_web_plugin_path(const cef_string_t* path) {
    DebugBreak();
}

CEF_EXPORT void cef_unregister_internal_web_plugin(const cef_string_t* path) {

}

CEF_EXPORT void cef_force_web_plugin_shutdown(const cef_string_t* path) {
    DebugBreak();
    // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING


}

CEF_EXPORT void cef_register_web_plugin_crash(const cef_string_t* path) {
    DebugBreak();
    // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING


}

CEF_EXPORT void cef_is_web_plugin_unstable(const cef_string_t* path, struct _cef_web_plugin_unstable_callback_t* callback) {
    DebugBreak();
    // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING
}

CEF_EXPORT int cef_version_info(int entry) {
    switch (entry) {
    case 0: return CEF_VERSION_MAJOR;
    case 1: return CEF_COMMIT_NUMBER;
    case 2: return CHROME_VERSION_MAJOR;
    case 3: return CHROME_VERSION_MINOR;
    case 4: return CHROME_VERSION_BUILD;
    case 5: return CHROME_VERSION_PATCH;
    default: return 0;
    }
}

#define CEF_API_HASH_WANG_YI "78d4b4eb20e36e2b08572b98645dde08e987fbad"

CEF_EXPORT const char* cef_api_hash(int entry) {
    switch (entry) {
    case 0: return CEF_API_HASH_PLATFORM; // CEF_API_HASH_PLATFORM; weolar
    case 1: return CEF_API_HASH_UNIVERSAL;
    case 2: return CEF_COMMIT_HASH;
    default: return NULL;
    }
}

CEF_EXPORT int cef_get_min_log_level() { return 100; }

CEF_EXPORT cef_platform_thread_handle_t cef_get_current_platform_thread_handle() {
    return (cef_platform_thread_handle_t)::GetCurrentThread();
}

CEF_EXPORT void cef_log(const char* file, int line, int severity, const char* message) {
    char* log = (char*)malloc(1000);
    sprintf_s(log, 999, "cef_log: %s %d %d %s", file, line, severity, message);
    OutputDebugStringA(log);
    free(log);
}

CEF_EXPORT int cef_time_to_timet(const cef_time_t* cef_time, time_t* time) { DebugBreak(); return 0; }
CEF_EXPORT int cef_time_from_timet(time_t time, cef_time_t* cef_time) { DebugBreak(); return 0; }

CEF_EXPORT int cef_time_to_doublet(const cef_time_t* cef_time, double* time) { DebugBreak(); return 0; }
CEF_EXPORT int cef_time_from_doublet(double time, cef_time_t* cef_time) { DebugBreak(); return 0; }

CEF_EXPORT int cef_time_now(cef_time_t* cef_time) { DebugBreak(); return 0; }

CEF_EXPORT int cef_time_delta(const cef_time_t* cef_time1,
    const cef_time_t* cef_time2,
    long long* delta) {
    DebugBreak(); return 0;
}

//////////////////////////////////////////////////////////////////////////

CEF_EXPORT int ClearCrashKeyValueImpl() { DebugBreak(); return 0; }
CEF_EXPORT int CrashForException() { DebugBreak(); return 0; }
CEF_EXPORT int DumpProcess() { DebugBreak(); return 0; }
CEF_EXPORT int DumpProcessWithoutCrash() { DebugBreak(); return 0; }
CEF_EXPORT int InjectDumpForHangDebugging() { DebugBreak(); return 0; }
CEF_EXPORT int InjectDumpProcessWithoutCrash() { DebugBreak(); return 0; }
CEF_EXPORT int IsSandboxedProcess() { DebugBreak(); return 0; }
